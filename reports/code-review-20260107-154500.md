# コードレビュー報告書

**レビュー日時**: 2026-01-07 15:45:00
**レビュアー**: レビュアー
**対象**: message-aggregator / MessageList.tsx - 新規メッセージ削除ボタン2秒間無効化機能
**ステータス**: ✅ 承認（軽微な改善推奨）

---

## 📋 サマリー

- **レビュー観点**: 型安全性、React Hooksの使用方法、メモリリーク防止、UX要件の充足
- **総合評価**: ⭐⭐⭐⭐☆ (4/5)
- **レビューしたファイル数**: 2 ファイル (MessageList.tsx, MessageItem.tsx)
- **指摘事項**: Critical: 0, High: 1, Medium: 2, Low: 1
- **規約準拠率**: 90%

---

## ✅ 良かった点

1. **明確な定数定義**: `NEW_MESSAGE_DELETE_DISABLE_MS = 2000` として定数が定義されており、マジックナンバーを避けています

2. **Mapを使用した効率的なデータ構造**: `newMessageAppearedAt` の状態管理に `Map<string, number>` を使用しており、検索・更新が O(1) で効率的です

3. **refを使用した既存メッセージの追跡**: `currentMessageTsSetRef` により、再読み込み時の新規メッセージ判定が正確に行われています

4. **MessageItem への deleteDisabled prop の適切な伝播**: `deleteDisabled={newMessageAppearedAt.has(message.ts)}` として正しく渡されています

5. **MessageItem側での適切な処理**: `deleteDisabled` が `true` の場合、ボタンの `disabled` 属性に反映され、`handleDeleteClick` で早期リターンが実装されています

6. **UX要件の完全な充足**: 要件（新規メッセージの削除ボタン2秒間無効化）が正確に実装されています

---

## 🔴 Critical（必須修正）

なし

---

## 🟡 High（強く推奨）

### 1. コード重複: 新規メッセージ検出・追跡ロジックの重複
**ファイル**: `src/app/components/MessageList.tsx:129-172` と `src/app/components/MessageList.tsx:211-257`

**内容**: `handleDelete` 関数内と `startCountdown` 関数内で、新規メッセージを検出して `setNewMessageAppearedAt` を更新し、2秒後に削除する同一のロジックが重複しています。

**理由**: DRY原則違反。将来の変更時に両方を修正する必要があり、バグの温床となります。

**修正案**: 共通の関数に抽出することを推奨します。

```typescript
const trackNewMessages = useCallback((existingTsSet: Set<string>, newMessages: SlackMessage[]) => {
  const now = Date.now();
  const newMessageTsSet = new Map<string, number>();

  for (const msg of newMessages) {
    if (!existingTsSet.has(msg.ts)) {
      newMessageTsSet.set(msg.ts, now);
    }
  }

  if (newMessageTsSet.size > 0) {
    setNewMessageAppearedAt((prev) => {
      const updated = new Map(prev);
      newMessageTsSet.forEach((appearedAt, msgTs) => {
        updated.set(msgTs, appearedAt);
      });
      return updated;
    });

    setTimeout(() => {
      setNewMessageAppearedAt((prev) => {
        const updated = new Map(prev);
        newMessageTsSet.forEach((_, msgTs) => {
          updated.delete(msgTs);
        });
        return updated;
      });
    }, NEW_MESSAGE_DELETE_DISABLE_MS);
  }

  setMessages(newMessages);
  currentMessageTsSetRef.current = new Set(newMessages.map((m) => m.ts));
}, []);
```

---

## 🟢 Medium（推奨）

### 1. setTimeoutのクリーンアップが未実装
**ファイル**: `src/app/components/MessageList.tsx:154-163`, `src/app/components/MessageList.tsx:238-247`

**内容**: 2秒後に `newMessageAppearedAt` を削除する `setTimeout` が複数箇所で使用されていますが、コンポーネントのアンマウント時にクリーンアップされていません。

**理由**: コンポーネントがアンマウントされた後に `setNewMessageAppearedAt` が呼び出されると、React の警告が発生する可能性があります（"Can't perform a React state update on an unmounted component"）。ただし、React 18以降ではこの警告は表示されなくなったため、優先度は Medium としています。

**修正案**: `useRef` で `setTimeout` のIDを追跡し、アンマウント時にクリアする。

```typescript
const newMessageTimersRef = useRef<Set<NodeJS.Timeout>>(new Set());

// setTimeout使用時
const timerId = setTimeout(() => {
  // ...
  newMessageTimersRef.current.delete(timerId);
}, NEW_MESSAGE_DELETE_DISABLE_MS);
newMessageTimersRef.current.add(timerId);

// useEffect cleanup
useEffect(() => {
  return () => {
    newMessageTimersRef.current.forEach(clearTimeout);
  };
}, []);
```

### 2. fetchMessagesがuseEffectの依存配列に含まれているが直接使用されていない
**ファイル**: `src/app/components/MessageList.tsx:293`

**内容**: `useEffect` の依存配列に `fetchMessages` が含まれていますが、エフェクト内で直接使用されておらず、代わりに `fetch` を直接呼び出しています。

**理由**: 依存配列と実際の使用が一致しておらず、紛らわしいです。

**修正案**: 依存配列から `fetchMessages` を削除するか、エフェクト内で `fetchMessages` を使用するよう整理してください。

---

## 🔵 Low（任意）

### 1. 型注釈の追加
**ファイル**: `src/app/components/MessageList.tsx:47`

**内容**: `useState<Map<string, number>>(new Map())` は良い型定義ですが、コメントに「ts -> 出現時刻のミリ秒」と記載されています。

**提案**: 型エイリアスを使用するとより明確になります。

```typescript
type MessageTimestamp = string;
type AppearedAtMillis = number;
type NewMessageAppearedAtMap = Map<MessageTimestamp, AppearedAtMillis>;

const [newMessageAppearedAt, setNewMessageAppearedAt] = useState<NewMessageAppearedAtMap>(new Map());
```

---

## 📊 コーディング規約チェックリスト

### TypeScript規約
- [x] 命名規則に準拠（camelCase、UPPER_SNAKE_CASE）
- [x] any型の不適切な使用なし
- [x] 型定義が適切（Map<string, number>）
- [x] エラーハンドリングが適切（catch内で適切に処理）

### React/Next.js規約
- [x] 関数コンポーネントを使用
- [x] Hooksのルールに準拠
- [x] useEffectの依存配列が指定されている
- [ ] コードの重複がある → High指摘参照
- [ ] setTimeoutのクリーンアップ未実装 → Medium指摘参照
- [x] アクセシビリティを考慮（disabled属性が適切に設定）

### YAGNI原則
- [x] 過剰な抽象化がないか → 問題なし
- [x] 未使用機能が追加されていないか → 問題なし
- [x] 未使用コードが残っていないか → 問題なし
- [x] 過度な汎用化がされていないか → 問題なし

---

## 🎯 UX要件の充足確認

| 要件 | 充足 | 備考 |
|------|------|------|
| メッセージ削除後の再読み込み | ✅ | `handleDelete` 内で実装済み |
| 新規メッセージの検出 | ✅ | `existingTsSet` との比較で正確に検出 |
| 削除ボタン2秒間無効化 | ✅ | `deleteDisabled` prop で制御 |
| 2秒経過後の有効化 | ✅ | `setTimeout` で自動的に Map から削除 |
| アイドル時の自動再読み込み | ✅ | `startCountdown` 内でも同様に実装 |

---

## 🎯 次回への改善提案

1. **共通ロジックの抽出**: 新規メッセージ追跡ロジックをカスタムフックまたはユーティリティ関数として抽出することで、保守性が向上します

2. **テストの追加**: 2秒間の無効化機能に対するユニットテストまたはE2Eテストの追加を検討してください

---

## 🔗 参照

- [TypeScript コーディング規約](../../../ai-org/src/ai-org-core/coding-standards/typescript.md)
- [React / Next.js コーディング規約](../../../ai-org/src/ai-org-core/coding-standards/react.md)

---

## 🔴 修正必須項目の追跡

### Critical・High指摘事項

| 項目ID | 内容 | 優先度 | 担当 |
|--------|------|--------|------|
| CR-001 | 新規メッセージ検出・追跡ロジックの重複 | High | 開発者 |

### QA開始の前提条件

本レビューでは **Critical指摘はなく、High指摘は1件のみ（コード重複）** です。

機能的には問題なく動作するため、以下の条件でQA開始を許可します：

- [x] Critical指摘なし
- [ ] High指摘（CR-001）は **QAと並行して修正可能**

**開発者へ**: CR-001の重複コードは、QA完了後のリファクタリングフェーズで対応しても構いません。機能的な問題はないため、現状のままQAを開始できます。

---

**承認条件**:
- Critical指摘がないため、条件付きで承認します
- High指摘（コード重複）はQA後のリファクタリングで対応可
